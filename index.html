<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Workflow Canvas</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM CDN -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel CDN for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons CDN -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        body { 
            font-family: 'Inter', sans-serif; 
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        .btn-action:active { transform: scale(0.95); }
        /* Custom scrollbar for a cleaner look */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo } = React;
        
        // Lucide Icon Component Wrapper
        const Icon = ({ name, size = 18, className = "" }) => {
            const iconRef = useRef(null);
            
            useEffect(() => {
                if (window.lucide && window.lucide.icons[name]) {
                    const iconElement = window.lucide.icons[name].toSvg({
                        size: size,
                        class: className
                    });
                    if (iconRef.current) {
                        iconRef.current.innerHTML = iconElement;
                    }
                }
            }, [name, size, className]);

            return <span ref={iconRef} className="inline-flex items-center justify-center" />;
        };

        const App = () => {
            // 프로젝트 상태
            const [projects, setProjects] = useState([
                {
                    id: 'p1',
                    title: 'AI 소설 집필 프로젝트',
                    description: '세계관 설정 및 초안 작성 워크플로우',
                    x: 100,
                    y: 150,
                    nodes: [
                        { id: 'n1', type: 'AI Planner', x: 50, y: 150, content: '전체 줄거리 기획', status: 'completed' },
                        { id: 'n2', type: 'Writer', x: 350, y: 150, content: '1장 초안 작성', status: 'idle' },
                    ],
                    connections: [{ from: 'n1', to: 'n2' }]
                },
                {
                    id: 'p2',
                    title: '개인 건강 관리 목표',
                    description: '운동 루틴 및 식단 최적화',
                    x: 600,
                    y: 150,
                    nodes: [],
                    connections: []
                }
            ]);

            // 상위 프로젝트 간 연결 상태
            const [projectConnections, setProjectConnections] = useState([{ from: 'p1', to: 'p2' }]);
            
            const [view, setView] = useState('dashboard');
            const [currentProjectId, setCurrentProjectId] = useState(null);
            
            // UI 상태
            const [selectedNode, setSelectedNode] = useState(null);
            const [isDragging, setIsDragging] = useState(false);
            const [draggedId, setDraggedId] = useState(null);
            const [offset, setOffset] = useState({ x: 0, y: 0 });
            
            // 연결 모드 상태
            const [connectionSource, setConnectionSource] = useState(null);

            const currentProject = useMemo(() => 
                projects.find(p => p.id === currentProjectId) || null
            , [projects, currentProjectId]);

            // 곡선 경로 계산 함수 (Bezier Curve)
            const getCurvePath = (startX, startY, endX, endY) => {
                const width = Math.abs(endX - startX);
                const horizontalOffset = Math.max(width / 2, 40);
                return `M ${startX} ${startY} C ${startX + horizontalOffset} ${startY}, ${endX - horizontalOffset} ${endY}, ${endX} ${endY}`;
            };

            // 프로젝트 추가
            const addProject = () => {
                const newId = `p-${Date.now()}`;
                setProjects(prev => [...prev, {
                    id: newId,
                    title: '새 프로젝트',
                    description: '설명을 입력하세요',
                    x: 100,
                    y: 100,
                    nodes: [],
                    connections: []
                }]);
            };

            // 노드 추가
            const addNode = () => {
                if (!currentProject) return;
                const newNode = {
                    id: `n-${Date.now()}`,
                    type: 'Task',
                    x: 100,
                    y: 100,
                    content: '새로운 작업을 입력하세요',
                    status: 'idle'
                };
                const newNodes = [...(currentProject.nodes || []), newNode];
                setProjects(prev => prev.map(p => p.id === currentProjectId ? { ...p, nodes: newNodes } : p));
            };

            // 연결 로직 (상위/하위 공용)
            const handleConnect = (targetId) => {
                if (!connectionSource || connectionSource === targetId) {
                    setConnectionSource(null);
                    return;
                }

                if (view === 'dashboard') {
                    const exists = projectConnections.find(c => c.from === connectionSource && c.to === targetId);
                    if (exists) {
                        setProjectConnections(prev => prev.filter(c => !(c.from === connectionSource && c.to === targetId)));
                    } else {
                        setProjectConnections(prev => [...prev, { from: connectionSource, to: targetId }]);
                    }
                } else {
                    const p = currentProject;
                    const exists = p.connections.find(c => c.from === connectionSource && c.to === targetId);
                    let newConns;
                    if (exists) {
                        newConns = p.connections.filter(c => !(c.from === connectionSource && c.to === targetId));
                    } else {
                        newConns = [...p.connections, { from: connectionSource, to: targetId }];
                    }
                    setProjects(prev => prev.map(proj => proj.id === currentProjectId ? { ...proj, connections: newConns } : proj));
                }
                setConnectionSource(null);
            };

            // 드래그 로직
            const handleMouseDown = (e, id) => {
                if (e.target.closest('.btn-action') || e.target.closest('.editable-input')) return;
                setIsDragging(true);
                setDraggedId(id);
                const item = view === 'dashboard' 
                    ? projects.find(p => p.id === id) 
                    : currentProject.nodes.find(n => n.id === id);
                if (item) setOffset({ x: e.clientX - item.x, y: e.clientY - item.y });
            };

            const handleMouseMove = (e) => {
                if (!isDragging || !draggedId) return;
                if (view === 'dashboard') {
                    setProjects(prev => prev.map(p => p.id === draggedId ? { ...p, x: e.clientX - offset.x, y: e.clientY - offset.y } : p));
                } else {
                    const newNodes = currentProject.nodes.map(n => n.id === draggedId ? { ...n, x: e.clientX - offset.x, y: e.clientY - offset.y } : n);
                    setProjects(prev => prev.map(p => p.id === currentProjectId ? { ...p, nodes: newNodes } : p));
                }
            };

            // 대시보드 화면
            if (view === 'dashboard') {
                return (
                    <div className="h-screen w-full bg-slate-50 flex flex-col overflow-hidden" onMouseMove={handleMouseMove} onMouseUp={() => setIsDragging(false)}>
                        <header className="bg-white border-b p-4 flex justify-between items-center z-20 shadow-sm">
                            <div className="flex items-center gap-3">
                                <Icon name="LayoutGrid" className="text-indigo-600" />
                                <h1 className="text-xl font-bold">Project Hub</h1>
                                {connectionSource && <span className="text-xs bg-amber-100 text-amber-700 px-2 py-1 rounded animate-pulse font-bold ml-4">연결할 대상을 선택하세요...</span>}
                            </div>
                            <button onClick={addProject} className="bg-indigo-600 text-white px-4 py-2 rounded-lg font-bold hover:bg-indigo-700 flex items-center gap-2 transition-all active:scale-95 shadow-lg">
                                <Icon name="Plus" size={18} /> 새 프로젝트
                            </button>
                        </header>

                        <div className="flex-1 relative bg-slate-100 overflow-auto">
                            <svg className="absolute inset-0 w-full h-full pointer-events-none">
                                {projectConnections.map((c, i) => {
                                    const f = projects.find(p => p.id === c.from);
                                    const t = projects.find(p => p.id === c.to);
                                    if (!f || !t) return null;
                                    const path = getCurvePath(f.x + 320, f.y + 100, t.x, t.y + 100);
                                    return <path key={i} d={path} fill="none" stroke="#cbd5e1" strokeWidth="3" strokeDasharray="8,8" />;
                                })}
                            </svg>

                            {projects.map(p => (
                                <div key={p.id} onMouseDown={(e) => handleMouseDown(e, p.id)} style={{ left: p.x, top: p.y }}
                                     className={`absolute w-80 bg-white rounded-2xl border-2 p-5 shadow-xl transition-all group ${connectionSource === p.id ? 'border-amber-400 ring-4 ring-amber-50 shadow-amber-100' : 'border-slate-200'}`}>
                                    <div className="flex justify-between mb-4">
                                        <div className="p-2 bg-indigo-50 rounded-lg text-indigo-600 shadow-inner"><Icon name="Folder" size={20} /></div>
                                        <div className="flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                            <button onClick={() => setConnectionSource(p.id)} className="btn-action p-2 hover:bg-amber-50 text-amber-600 rounded-lg transition-colors" title="Connect"><Icon name="Link2" size={18} /></button>
                                            {connectionSource && connectionSource !== p.id && <button onClick={() => handleConnect(p.id)} className="btn-action p-2 bg-indigo-600 text-white rounded-lg animate-bounce" title="Target"><Icon name="MousePointer2" size={18} /></button>}
                                            <button onClick={() => setProjects(prev => prev.filter(proj => proj.id !== p.id))} className="btn-action p-2 hover:bg-red-50 text-red-400 rounded-lg transition-colors"><Icon name="Trash2" size={18} /></button>
                                        </div>
                                    </div>
                                    <input className="editable-input w-full font-bold text-lg mb-1 outline-none bg-transparent focus:border-b-2 border-indigo-200" value={p.title} onChange={e => setProjects(prev => prev.map(proj => proj.id === p.id ? {...proj, title: e.target.value} : proj))} />
                                    <textarea className="editable-input w-full text-xs text-slate-500 mb-4 bg-transparent outline-none resize-none h-12 leading-relaxed" value={p.description} onChange={e => setProjects(prev => prev.map(proj => proj.id === p.id ? {...proj, description: e.target.value} : proj))} />
                                    <div className="flex justify-between border-t pt-4">
                                        <span className="text-[10px] font-bold text-slate-400 bg-slate-50 px-2 py-0.5 rounded border uppercase">{(p.nodes || []).length} Blocks</span>
                                        <button onClick={() => { setCurrentProjectId(p.id); setView('canvas'); }} className="btn-action text-indigo-600 font-bold text-sm flex items-center gap-1 hover:gap-2 transition-all">진입하기 <Icon name="ArrowRight" size={16} /></button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            }

            // 프로젝트 내부 캔버스
            return (
                <div className="flex h-screen w-full bg-slate-50 overflow-hidden font-sans" onMouseMove={handleMouseMove} onMouseUp={() => setIsDragging(false)}>
                    <aside className="w-64 bg-white border-r p-4 flex flex-col gap-4 z-10 shadow-lg">
                        <button onClick={() => { setView('dashboard'); setConnectionSource(null); }} className="flex items-center gap-2 text-slate-400 hover:text-indigo-600 mb-4 font-semibold transition-colors"><Icon name="ChevronLeft" size={20} /> 허브로 돌아가기</button>
                        <button onClick={addNode} className="bg-indigo-600 text-white py-3 rounded-xl font-bold shadow-indigo-200 shadow-lg hover:bg-indigo-700 transition-all flex items-center justify-center gap-2 active:scale-95"><Icon name="Plus" size={18} /> 블록 추가</button>
                        {connectionSource && <div className="p-3 bg-amber-50 text-amber-700 rounded-lg text-[10px] font-bold animate-pulse uppercase border border-amber-200">연결 대상을 클릭하세요</div>}
                    </aside>

                    <main className="flex-1 relative bg-slate-100 overflow-hidden">
                        <div className="absolute inset-0 opacity-10 pointer-events-none" style={{ backgroundImage: 'radial-gradient(#94a3b8 1px, transparent 1px)', backgroundSize: '30px 30px' }}></div>
                        <svg className="absolute inset-0 w-full h-full pointer-events-none">
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8" />
                                </marker>
                            </defs>
                            {(currentProject?.connections || []).map((c, i) => {
                                const f = currentProject.nodes.find(n => n.id === c.from);
                                const t = currentProject.nodes.find(n => n.id === c.to);
                                if (!f || !t) return null;
                                const startX = f.x + 192;
                                const startY = f.y + 40;
                                const endX = t.x - 4;
                                const endY = t.y + 40;
                                const path = getCurvePath(startX, startY, endX, endY);
                                return <path key={i} d={path} fill="none" stroke="#94a3b8" strokeWidth="2.5" markerEnd="url(#arrowhead)" />;
                            })}
                        </svg>

                        {(currentProject?.nodes || []).map(n => (
                            <div key={n.id} onMouseDown={(e) => handleMouseDown(e, n.id)} style={{ left: n.x, top: n.y }}
                                 className={`absolute w-48 p-4 rounded-2xl bg-white shadow-lg border-2 transition-all cursor-grab active:cursor-grabbing 
                                 ${selectedNode?.id === n.id ? 'border-indigo-500 ring-4 ring-indigo-50 scale-105 z-10' : connectionSource === n.id ? 'border-amber-400 ring-4 ring-amber-50' : 'border-transparent hover:border-slate-200'}`}
                                 onClick={() => connectionSource ? handleConnect(n.id) : setSelectedNode(n)}>
                                <div className="flex justify-between items-start mb-2">
                                    <span className={`text-[9px] font-black uppercase px-2 py-0.5 rounded border ${n.status === 'completed' ? 'bg-emerald-50 text-emerald-600 border-emerald-100' : 'bg-slate-50 text-slate-500 border-slate-100'}`}>{n.status}</span>
                                    <button onClick={(e) => { e.stopPropagation(); setConnectionSource(n.id); }} className="btn-action text-slate-300 hover:text-amber-500 p-1 hover:bg-slate-50 rounded-lg"><Icon name="Link2" size={16} /></button>
                                </div>
                                <h3 className="font-bold text-sm text-slate-800 mb-1">{n.type}</h3>
                                <p className="text-[10px] text-slate-500 leading-relaxed line-clamp-3">{n.content}</p>
                            </div>
                        ))}
                    </main>

                    {selectedNode && (
                        <section className="w-80 bg-white border-l p-5 flex flex-col z-20 shadow-2xl animate-in slide-in-from-right duration-300">
                            <div className="flex justify-between items-center mb-6 border-b pb-4">
                                <div>
                                    <h2 className="font-bold text-slate-800">Block Info</h2>
                                </div>
                                <button onClick={() => setSelectedNode(null)} className="p-2 hover:bg-slate-100 rounded-full transition-colors"><Icon name="X" size={20} /></button>
                            </div>
                            <div className="space-y-6 flex-1 pr-1 overflow-auto">
                                <div className="space-y-2">
                                    <label className="text-[10px] font-bold text-slate-400 uppercase tracking-widest">내용</label>
                                    <textarea className="w-full p-3 bg-slate-50 border border-slate-100 rounded-xl h-48 outline-none focus:border-indigo-500 focus:bg-white transition-all text-sm leading-relaxed" 
                                              value={selectedNode.content}
                                              onChange={e => {
                                                  const val = e.target.value;
                                                  const newNodes = currentProject.nodes.map(node => node.id === selectedNode.id ? {...node, content: val} : node);
                                                  setProjects(prev => prev.map(p => p.id === currentProjectId ? {...p, nodes: newNodes} : p));
                                                  setSelectedNode({...selectedNode, content: val});
                                              }} />
                                </div>
                            </div>
                            <button onClick={() => {
                                const newNodes = currentProject.nodes.filter(node => node.id !== selectedNode.id);
                                setProjects(prev => prev.map(p => p.id === currentProjectId ? {...p, nodes: newNodes} : p));
                                setSelectedNode(null);
                            }} className="mt-6 w-full py-3 bg-red-50 text-red-500 rounded-xl font-bold hover:bg-red-500 hover:text-white transition-all flex items-center justify-center gap-2 border border-red-100">
                                <Icon name="Trash2" size={18} /> 블록 삭제
                            </button>
                        </section>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
